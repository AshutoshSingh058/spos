MZ¬ê       √ø√ø  ¬∏       @                                   ‚Ç¨   ¬∫ ¬¥	√ç!¬∏L√ç!
$       PE  d‚Ä† z√≠o`        √∞ " 
0  √∫                    ‚Ç¨                         @    45  `‚Ä¶  @      @                                               $            ÀÜ(          x                                                                H           .text   √∞√π       √∫                    `.rsrc   $         √º              @  @                                        H     $o  T¬©                                                         0 }       (  
r  p(  
}  s  
}  (  
{  (  
-{  (  
&(
  (  {  ,'{  r_  p(  
(  
}  {  o  
*^~  -
s	  ‚Ç¨  ~  *   0 ‚Äô     {  

(  
{  ,l{  ,d{  ¬ç  %r‚Ä¢  p¬¢%(  
r¬°  p(  
¬¢%r√ï  p¬¢%~]  ¬¢%r√ô  p¬¢%(  
o  

(  
¬¢%¬¢(  
o  
√û
 ,(   
√ú*     	 ~‚Ä° 
    0 ‚Äô     {  

(  
{  ,l{  ,d{  ¬ç  %r√´  p¬¢%(  
r¬°  p(  
¬¢%r√ï  p¬¢%~]  ¬¢%r√ô  p¬¢%(  
o  

(  
¬¢%¬¢(  
o  
√û
 ,(   
√ú*     	 ~‚Ä° 
    0       {  r_  p(  

(!  
,("  
*0 O     ~#  
r√∑  po$  

,;o%  
r¬¶ p(  +,#r¬¶ po'  
¬•V  2	}  + }  o(  
**   0 \     
~)  

~
  
	(  
+*~   ~  (  
(*  
.X
~  .,√ì √ü√û
,	(   
√ú*    <O 
    0 ?     

~
  
(  
+(   ,
X
~  3√û -√•√û
	,(   
√ú *     '3 
    0 ¬∞     

(+  

~
  (  
+c~   ~  	(  	(,  

 3√ûW ~¬ê  %-&~¬è  √æ s-  
%‚Ç¨¬ê  d(.  
&r¬∏ p ≈íV  ≈í^  (/  
X

2Àú√û, (   
√ú	~)  
(0  
,	(1  
 *    u¬è     0 c     
@¬ç`  
    ¬ç`  
 Q≈ì √±   YE      '   o   L   L   +m  ‚Äö   ≈ì  √ê   ≈ì ≈ì  ≈ì   ≈ì
X+H  ‚Äö   ≈ì  √ê   ≈ì ≈ì  ≈∏   ≈ì
X+#  ‚Äö   ≈ì  √ê   ≈ì ≈ì  ‚Ñ¢   ≈ì
X    ¬ç`  Q (*  
3*~
  (  
~	   	(  n	j.
~‚Äò  %-&~¬è  √æ s-  
%‚Ç¨‚Äò  
(.  
&,;~	  (  nj3'‚Äò," +P  X‚Äò≈ì X  ‚Äò_2√•√û
√û, (   
√ú*    √ë ‚ÄûU    0 ‚Äö     
(
  r p (2  
(  
o
   (*  
3*~
  
 (  
~‚Äô  %-&~¬è  √æ s-  
%‚Ç¨‚Äô  d(.  
&~	  (  nj.
√û
, (   
√ú*     1 Ev 
    0 √ó   	  
¬ç`  %√ê≈Ω  (3  

    ¬ç`  
    ¬ç`  Q (*  
3*~	    ≈Ωi(  n ≈Ωij.
~‚Äú  %-&~¬è  √æ  s-  
%‚Ç¨‚Äú  
(.  
&~	  	(  + r: p≈íV  	‚Äò≈í`  (/  
X2√õnj.
+P	X‚Äò≈ìXY2√®* 0 -   
  

+ -na√í
+
P Y‚Äòa√í
 X
 X2√°PY≈ì*   0 A       
‚Ç¨  r≈† p   (4  
‚Ç¨   r‚Äù p   (4  
‚Ç¨  7‚Ç¨	  s  
‚Ç¨
  *¬∂s2  }
   √ø   ¬ç^  }  (  
(
  }
  *o5  
*o6  
* 0 1   
  ¬çV  
(7  
(  +
+ ‚Äù0 Y. X
 2√¨ ‚Äù*   0 ¬µ    {
  r≈æ po
  {
  r√∂ po9  
≈íV  (:  
o
  {
  rf po;  
≈íV  (:  
o
  o<  
≈Ωi
 √ø   ¬ç`  ¬ç`  
Q≈ì √ê   ≈ì{
  o<  
‚Ä¢o9  
o/  
 ‚Äò √ø   _(=  
≈ì ‚Äò √ø   _(=  
≈ì ‚Äò √ø   _(=  
≈ì{
  ¬ç  %r√í p¬¢%o;  
≈íV  ¬¢%r@ p¬¢%o>  
≈íV  ¬¢%rb p¬¢%o?  
≈í  ¬¢(  
o
  o?  
≈í  √æ  o@  
:¬≠   (   ≈í   ≈ì≈ì3{
  o<  
‚Ä¢o9  
o/  
	‚Äò √ø   _(=  
≈ì		‚Äò √ø   _(=  
≈ì
	‚Äò √ø   _(=  
≈ì
{
  o1   √ø   _(A  
≈ì‚Äò √ø   _(=  
≈ì
‚Äò √ø   _(=  
≈ì8√â   o?  
≈í  √æ  o@  
-C(   ÀÜ   ≈ì≈ì{
  o1   √ø   _(A  
≈ì	‚Äò √ø   _(=  
≈ì+io?  
≈í  √æ  o@  
-' ‚Ä°   ≈ì≈ì{
  o1   √ø   _(A  
≈ì+% ‚Äπ   ≈ì≈ì{
  o1   √ø   _(A  
≈ì*   0 g   
  ¬ç`  
o?  

 . .-+M≈ìo>  
3 ≈ì+9o>  
3 
≈ì+)≈ì+"o>  
- 
≈ì+o>  
3≈ì+≈ì* 0 ^     

oB  
oC  

+D oB  
oD  
.oB  
oD  
Y+oB  
oD  
_b`
  √ø   _(=  

X
2¬∏	*  0 ÀÜ     oE  
oF  
o?  



1. i
#include <bits/stdc++.h>
using namespace std;

int main() {
    ifstream fin("ass1ip.txt");
    ofstream inter("intermediate.txt"), sym("symtab.txt");

    map<string, string> OPTAB = {
        {"START", ""}, {"MOVER", "04"}, {"ADD", "01"},
        {"SUB", "02"}, {"MOVEM", "05"}, {"END", ""}
    };

    string line;
    int locctr = 0, start = 0;

    while (getline(fin, line)) {
        if (line.empty()) continue;

        // Replace commas with spaces
        replace(line.begin(), line.end(), ',', ' ');
        stringstream ss(line);
        vector<string> tok;
        string temp;
        while (ss >> temp) tok.push_back(temp);

        // START
        if (tok[0] == "START") {
            start = stoi(tok[1]);
            locctr = start;
            inter << "START " << start << "\n";
        }
        // END
        else if (tok[0] == "END") {
            inter << "END\n";
            break;
        }
        // LABEL + OPCODE (e.g., LOOP SUB CREG, D)
        else if (OPTAB.find(tok[0]) == OPTAB.end()) {
            string label = tok[0];
            string opcode = tok[1];
            string operand = (tok.size() > 3) ? tok[3] : tok.back();
            sym << label << " " << locctr << "\n";
            inter << locctr << " " << opcode << " " << operand << "\n";
            locctr += 3;
        }
        // NO LABEL (e.g., MOVER AREG, B)
        else {
            string opcode = tok[0];
            string operand = (tok.size() > 2) ? tok[2] : tok.back();
            inter << locctr << " " << opcode << " " << operand << "\n";
            locctr += 3;
        }
    }

    cout << "PASS 1 complete. (intermediate.txt & symtab.txt created)\n";
}

1 .ii

#include <bits/stdc++.h>
using namespace std;

int main() {
    ifstream inter("intermediate.txt"), sym("symtab.txt");
    ofstream out("output.txt");

    // --- Load Symbol Table ---
    map<string, string> SYMTAB;
    string symb, addr;
    while (sym >> symb >> addr)
        SYMTAB[symb] = addr;

    // --- Operation Table ---
    map<string, string> OPTAB = {
        {"MOVER", "04"}, {"ADD", "01"},
        {"SUB", "02"}, {"MOVEM", "05"}
    };

    string line;
    while (getline(inter, line)) {
        if (line.empty()) continue;
        stringstream ss(line);
        vector<string> tok;
        string t;
        while (ss >> t) tok.push_back(t);

        if (tok[0] == "START" || tok[0] == "END")
            continue;

        // Each instruction line has: loc opcode operand
        if (tok.size() >= 3) {
            string loc = tok[0];
            string opcode = tok[1];
            string operand = tok[2];

            string opCode = OPTAB[opcode];
            string opAddr = SYMTAB.count(operand) ? SYMTAB[operand] : operand;

            out << loc << " " << opCode << " " << opAddr << "\n";
        }
    }

    cout << "PASS 2 complete ‚Äî output.txt generated successfully.\n";
}


input

START 100
MOVER AREG, B
ADD BREG, C
LOOP SUB CREG, D
MOVEM AREG, D
END






2. i

#include <bits/stdc++.h>
using namespace std;

struct MNT {
    string name;
    int mdtIndex;
};

int main() {
    ifstream fin("macroip.txt");
    ofstream mdt("mdt.txt"), mnt("mnt.txt"), inter("intermediate.txt");

    vector<MNT> mntTable;
    string line;
    bool inMacro = false;
    int mdtIndex = 1;

    while (getline(fin, line)) {
        stringstream ss(line);
        string first;
        ss >> first;

        if (first == "MACRO") {
            // next line contains macro header
            getline(fin, line);
            stringstream header(line);
            string macroName;
            header >> macroName;
            mntTable.push_back({macroName, mdtIndex});
            inMacro = true;
            continue;
        }

        if (inMacro) {
            if (line == "MEND") {
                mdt << "MEND\n";
                mdtIndex++;
                inMacro = false;
            } else {
                mdt << line << "\n";
                mdtIndex++;
            }
        } else {
            inter << line << "\n";
        }
    }

    for (auto &m : mntTable)
        mnt << m.name << " " << m.mdtIndex << "\n";

    cout << "PASS 1 done.\n";
}


2 . ii
#include <bits/stdc++.h>
using namespace std;

struct MNT {
    string name;
    int mdtIndex;
};

int main() {
    ifstream inter("intermediate.txt"), mdt("mdt.txt"), mnt("mnt.txt");
    ofstream out("output.txt");

    vector<MNT> mntTable;
    string line;
    while (getline(mnt, line)) {
        string name; int idx;
        stringstream ss(line);
        ss >> name >> idx;
        mntTable.push_back({name, idx});
    }

    vector<string> MDT;
    while (getline(mdt, line))
        MDT.push_back(line);

    while (getline(inter, line)) {
        stringstream ss(line);
        string word; ss >> word;
        bool expanded = false;

        for (auto &m : mntTable) {
            if (word == m.name) {
                string arg; ss >> arg;
                for (int i = m.mdtIndex - 1; i < (int)MDT.size(); i++) {
                    if (MDT[i] == "MEND") break;
                    string temp = MDT[i];
                    size_t pos = temp.find("&ARG1");
                    if (pos != string::npos)
                        temp.replace(pos, 6, arg);
                    out << temp << "\n";
                }
                expanded = true;
                break;
            }
        }
        if (!expanded) out << line << "\n";
    }

    cout << "PASS 2 done.\n";
}


MACRO
INCR &ARG1
LDA &ARG1
ADD =1
STA &ARG1
MEND
START
INCR A
INCR B
END




4.
#include <iostream>
#include <queue>
#include <semaphore.h>
#include <pthread.h>
#include <unistd.h>
using namespace std;

#define BUFFER_SIZE 5

queue<int> buffer;
sem_t emptySlots, fullSlots, mutexLock;

void* producer(void* arg) {
    for (int i = 1; i <= 5; i++) {
        sem_wait(&emptySlots);   // wait for empty slot
        sem_wait(&mutexLock);    // enter critical section

        buffer.push(i);
        cout << "Produced: " << i << endl;

        sem_post(&mutexLock);    // leave critical section
        sem_post(&fullSlots);    // signal item produced
        sleep(1);
    }
    pthread_exit(NULL);
}

void* consumer(void* arg) {
    for (int i = 1; i <= 5; i++) {
        sem_wait(&fullSlots);    // wait for available item
        sem_wait(&mutexLock);    // enter critical section

        int item = buffer.front();
        buffer.pop();
        cout << "Consumed: " << item << endl;

        sem_post(&mutexLock);    // leave critical section
        sem_post(&emptySlots);   // signal space available
        sleep(2);
    }
    pthread_exit(NULL);
}

int main() {
    pthread_t prodThread, consThread;

    sem_init(&emptySlots, 0, BUFFER_SIZE);
    sem_init(&fullSlots, 0, 0);
    sem_init(&mutexLock, 0, 1);

    pthread_create(&prodThread, NULL, producer, NULL);
    pthread_create(&consThread, NULL, consumer, NULL);

    pthread_join(prodThread, NULL);
    pthread_join(consThread, NULL);

    sem_destroy(&emptySlots);
    sem_destroy(&fullSlots);
    sem_destroy(&mutexLock);

    return 0;
}



5.
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Process {
    int pid, bt, at, wt, tat, prio, remaining;
};

void printTable(vector<Process>& p) {
    cout << "\nPID\tAT\tBT\tWT\tTAT\n";
    for (auto &x : p)
        cout << x.pid << "\t" << x.at << "\t" << x.bt << "\t" << x.wt << "\t" << x.tat << endl;
}

void fcfs(vector<Process> p) {
    cout << "\n--- FCFS Scheduling ---\n";
    sort(p.begin(), p.end(), [](auto &a, auto &b){ return a.at < b.at; });
    int time = 0;
    for (auto &x : p) {
        if (time < x.at) time = x.at;
        x.wt = time - x.at;
        time += x.bt;
        x.tat = x.wt + x.bt;
    }
    printTable(p);
}

void sjfPreemptive(vector<Process> p) {
    cout << "\n--- SJF (Preemptive) Scheduling ---\n";
    int n = p.size(), complete = 0, t = 0, minm = 1e9;
    int shortest = 0, finish_time;
    bool check = false;
    for (auto &x : p) x.remaining = x.bt;

    while (complete != n) {
        for (int j = 0; j < n; j++) {
            if ((p[j].at <= t) && (p[j].remaining < minm) && p[j].remaining > 0) {
                minm = p[j].remaining;
                shortest = j;
                check = true;
            }
        }

        if (!check) { t++; continue; }

        p[shortest].remaining--;
        minm = p[shortest].remaining == 0 ? 1e9 : p[shortest].remaining;

        if (p[shortest].remaining == 0) {
            complete++;
            check = false;
            finish_time = t + 1;
            p[shortest].wt = finish_time - p[shortest].bt - p[shortest].at;
            if (p[shortest].wt < 0) p[shortest].wt = 0;
            p[shortest].tat = p[shortest].bt + p[shortest].wt;
        }
        t++;
    }
    printTable(p);
}

void priorityNonPreemptive(vector<Process> p) {
    cout << "\n--- Priority (Non-Preemptive) Scheduling ---\n";
    sort(p.begin(), p.end(), [](auto &a, auto &b){
        return (a.prio == b.prio) ? a.at < b.at : a.prio < b.prio;
    });
    int time = 0;
    for (auto &x : p) {
        if (time < x.at) time = x.at;
        x.wt = time - x.at;
        time += x.bt;
        x.tat = x.wt + x.bt;
    }
    printTable(p);
}

void roundRobin(vector<Process> p, int quantum) {
    cout << "\n--- Round Robin Scheduling ---\n";
    int n = p.size(), t = 0;
    for (auto &x : p) x.remaining = x.bt;
    while (true) {
        bool done = true;
        for (int i = 0; i < n; i++) {
            if (p[i].remaining > 0) {
                done = false;
                if (p[i].remaining > quantum) {
                    t += quantum;
                    p[i].remaining -= quantum;
                } else {
                    t += p[i].remaining;
                    p[i].wt = t - p[i].bt;
                    p[i].remaining = 0;
                    p[i].tat = p[i].wt + p[i].bt;
                }
            }
        }
        if (done) break;
    }
    printTable(p);
}

int main() {
    int n;
    cout << "Enter number of processes: ";
    cin >> n;
    vector<Process> p(n);
    for (int i = 0; i < n; i++) {
        p[i].pid = i + 1;
        cout << "Enter AT, BT, Priority for P" << i + 1 << ": ";
        cin >> p[i].at >> p[i].bt >> p[i].prio;
    }

    fcfs(p);
    sjfPreemptive(p);
    priorityNonPreemptive(p);
    int q;
    cout << "\nEnter Quantum for Round Robin: ";
    cin >> q;
    roundRobin(p, q);
    return 0;
}


6.


#include <iostream>
#include <vector>
using namespace std;

void firstFit(vector<int> blocks, vector<int> process) {
    cout << "\n--- First Fit ---\n";
    vector<int> alloc(process.size(), -1);
    for (int i = 0; i < process.size(); i++) {
        for (int j = 0; j < blocks.size(); j++) {
            if (blocks[j] >= process[i]) {
                alloc[i] = j;
                blocks[j] -= process[i];
                break;
            }
        }
    }
    for (int i = 0; i < process.size(); i++)
        cout << "Process " << i + 1 << " -> "
             << (alloc[i] == -1 ? "Not Allocated" : "Block " + to_string(alloc[i] + 1)) << endl;
}

void bestFit(vector<int> blocks, vector<int> process) {
    cout << "\n--- Best Fit ---\n";
    vector<int> alloc(process.size(), -1);
    for (int i = 0; i < process.size(); i++) {
        int best = -1;
        for (int j = 0; j < blocks.size(); j++)
            if (blocks[j] >= process[i])
                if (best == -1 || blocks[j] < blocks[best])
                    best = j;
        if (best != -1) {
            alloc[i] = best;
            blocks[best] -= process[i];
        }
    }
    for (int i = 0; i < process.size(); i++)
        cout << "Process " << i + 1 << " -> "
             << (alloc[i] == -1 ? "Not Allocated" : "Block " + to_string(alloc[i] + 1)) << endl;
}

void worstFit(vector<int> blocks, vector<int> process) {
    cout << "\n--- Worst Fit ---\n";
    vector<int> alloc(process.size(), -1);
    for (int i = 0; i < process.size(); i++) {
        int worst = -1;
        for (int j = 0; j < blocks.size(); j++)
            if (blocks[j] >= process[i])
                if (worst == -1 || blocks[j] > blocks[worst])
                    worst = j;
        if (worst != -1) {
            alloc[i] = worst;
            blocks[worst] -= process[i];
        }
    }
    for (int i = 0; i < process.size(); i++)
        cout << "Process " << i + 1 << " -> "
             << (alloc[i] == -1 ? "Not Allocated" : "Block " + to_string(alloc[i] + 1)) << endl;
}

void nextFit(vector<int> blocks, vector<int> process) {
    cout << "\n--- Next Fit ---\n";
    vector<int> alloc(process.size(), -1);
    int pos = 0;
    for (int i = 0; i < process.size(); i++) {
        int count = 0;
        while (count < blocks.size()) {
            if (blocks[pos] >= process[i]) {
                alloc[i] = pos;
                blocks[pos] -= process[i];
                break;
            }
            pos = (pos + 1) % blocks.size();
            count++;
        }
    }
    for (int i = 0; i < process.size(); i++)
        cout << "Process " << i + 1 << " -> "
             << (alloc[i] == -1 ? "Not Allocated" : "Block " + to_string(alloc[i] + 1)) << endl;
}

int main() {
    int nb, np;
    cout << "Enter number of memory blocks: ";
    cin >> nb;
    vector<int> blocks(nb);
    cout << "Enter block sizes: ";
    for (int i = 0; i < nb; i++) cin >> blocks[i];

    cout << "Enter number of processes: ";
    cin >> np;
    vector<int> process(np);
    cout << "Enter process sizes: ";
    for (int i = 0; i < np; i++) cin >> process[i];

    firstFit(blocks, process);
    bestFit(blocks, process);
    worstFit(blocks, process);
    nextFit(blocks, process);

    return 0;
}




7.

#include <bits/stdc++.h>
using namespace std;

int main() {
    int n=0, frameCount =0, pageFaults = 0;
    cout << " Enter No of pages:";
    cin>> n;
    
    vector<int> pages(n,0);   
    cout<< "Enter page reference string:";
    for(int i=0; i<n; i++) cin>> pages[i];

    cout<< "Enter no. of frames:";
    cin>> frameCount;

    // vector<int> frames;
    queue<int> q;

    for (int i =0; i<n; i++){
        int page = pages[i];
        bool found = false;

        queue<int> q2 = q;
        while (!q2.empty()){
            int f = q2.front();
            q2.pop();
            if ( page == f ) found;
        }

        if( !found){
            pageFaults++;
            q.push(page);
            
            while(q.size() > frameCount) q.pop();
        }

        cout<< "After page"<<page<<" : ";

        queue<int> q3 = q;
        while (!q3.empty()){
            int f = q3.front();
            q3.pop();
            cout<< f<<" ";
        }
        cout<<endl;
    }

    cout<< "\nTotal page fault = "<<pageFaults<<endl;

    return 0;
}